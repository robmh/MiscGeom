% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/SLOWER_distance_filter.R, R/distance_filter.R
\name{distance_filter}
\alias{distance_filter}
\title{Distance-based spatial filtering}
\usage{
distance_filter(
  df,
  min_dist,
  strictly = TRUE,
  columns = NULL,
  method = "euclidean",
  shuffle = T,
  verbose = T
)

distance_filter(
  df,
  min_dist,
  strictly = TRUE,
  columns = NULL,
  method = "euclidean",
  shuffle = T,
  verbose = T
)
}
\arguments{
\item{df}{numeric \code{data.frame} with as many rows as points to be included in the analysis.}

\item{min_dist}{\code{numeric}, minimum distance value between points.}

\item{strictly}{\code{logical}, set it to \code{TRUE} to evaluate distance strictly larger than \code{min_dist}.
Default is \code{FALSE}, i.e. distances can be larger or equal to \code{min_dist}.}

\item{columns}{character vector, name of the columns in \code{df} to be used to measure distance.}

\item{method}{The method to be used (see \link[stats]{dist} for details).}

\item{shuffle}{\code{logical}, set it to \code{TRUE} to randomly shuffle the points in \code{df}.
If not set, algorithm will always start at first row and will move down to the last one.
By default it is set to \code{TRUE}, which means that every time \code{distance_filter} is
called the result will likely be different.}

\item{verbose}{logical, if TRUE a progress bar will be printed on terminal.}

\item{strict}{}
}
\value{
A \code{data.frame} with as many columns as \code{df} and with rows containing points that are
separated by at least a distance \code{min_dist}. Coordinates for points can be of any dimension, i.e.
\code{df} can have as many columns as needed (distances are calculated with the built-in \link[stats]{dist} function).
If all distances are less than \code{min_dist} NA is returned.

A \code{data.frame} with as many columns as \code{df} and with rows containing points that are
separated by at least a distance \code{min_dist}. Coordinates for points can be of any dimension, i.e.
\code{df} can have as many columns as needed (distances are calculated with the built-in \link[stats]{dist} function).
If all distances are less than \code{min_dist}, NA is returned.
}
\description{
Function \code{distance_filter} applies a spatial filter to a set of N-dimensional coordinates such that
the resulting points are separated by at least a minimum distance.

Function \code{distance_filter} applies a spatial filter to a set of N-dimensional coordinates such that
the resulting points are separated by at least a minimum distance.
}
\details{
Simple algorithm that goes point by point checking its distance to all others.
}
\examples{

# Random set of 2-D coordinates.
df <- data.frame(x1 = runif(10000)*10, x2 = runif(10000)*10)

# Compute filtered and shuffled+filtered datasets. If you repeat the lines below
# you'll notice that the "Original" and the "Filtered" plots do not change.
par(mfcol = c(1, 3))
plot(df, xlim = c(0, 10), ylim = c(0, 10), main = "Original", pch = 16, cex = .1)
df_filt <- distance_filter(df, 2, shuffle = F)
plot(df_filt, xlim = c(0, 10), ylim = c(0, 10), main = "Filtered")
df_shuff_filt <- distance_filter(df, 2, shuffle = T)
plot(df_shuff_filt, xlim = c(0, 10), ylim = c(0, 10), main = "Shuffled + Filtered")
par(mfcol = c(1, 1))


# If the grid is perfectly squared and interpoint distance is >=2 exactly,
the output is exactly as the input when 'strict' is FALSE.
df <- as.data.frame(expand.grid(seq(0, 10, by = 2), seq(0, 10, by = 2)))
df_square <- distance_filter(df, 2, shuffle = FALSE, strict = FALSE)
identical(df, df_square)

# If we add a small amount of jittering to the coordinates, the results change a great deal.
df <- data.frame(jitter(df[, 1], .001), jitter(df[, 2], .001))
df_jitter <- distance_filter(df, 2, shuffle = FALSE, strict = FALSE)

# install.packages(c("sf", "gstat", "sp))

library(sp)
data(meuse)

# First we plot a variogram with all points.
meuse_sf <- sf::st_as_sf(meuse, coords = c("x", "y"), crs = NA)
cutoff <- 4000
vmeuse <- gstat::variogram(log(zinc) ~ 1, data = meuse_sf, boundaries = boundaries, cutoff = cutoff)
plot(vmeuse, main = "Variogram", type="l", lwd=2,xlim=c(0, 4000), ylim=c(0, 1.5))

# We now choose distance = 500 as our minimum distance value.
min_dist <- 500
cutoff <- 4000
boundaries <- seq(min_dist, cutoff, by = 250)

# Compute and plot variogram. Every time 'distance_filter' is run the resulting filtered 
# dataset is different. 
meuse_filtered <- distance_filter(meuse, min_dist = min_dist, columns = c("x", "y"), verbose = FALSE)
meuse_filtered_sf <- sf::st_as_sf(meuse_filtered, coords = c("x", "y"), crs = NA)
v1 <- gstat::variogram(log(zinc) ~ 1, data = meuse_filtered_sf, boundaries = boundaries, cutoff = cutoff)
plot(v1, main = "Filtered variogram", xlim = c(0, 4000), ylim = c(0, 1.5))

}
